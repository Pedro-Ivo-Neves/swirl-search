# Referência para Desenvolvedores
{:.no_toc}

**Conteúdo**
* TOC
{:toc}

## Público-Alvo

Este guia tem como objetivo fornecer informações de referência detalhadas sobre o Swirl para desenvolvedores. Consulte o [Guia do Desenvolvedor](5.-Guia-do-Desenvolvedor.md) para obter uma visão geral de como trabalhar com o Swirl.

<br/>

# Tabela de Estados

A tabela a seguir descreve em mais detalhes todas as etapas no processo de federação, com o respectivo `status` associado e outras informações de estado importantes.

| Ação | Módulo | Status | Notas | 
| ---------- | ---------- | ---------- | ---------- | 
| Objeto de pesquisa criado | views.py SearchViewSet.list() | Search.status:<br/>NEW_SEARCH<br/>UPDATE_SEARCH | Necessário:<br/>`Search.query_string` |
| Pré-processamento | search.py search() | Search.status:<br/>PRE_PROCESSING | Verifica permissões<br/>Carrega o objeto de pesquisa |
| Pré-processamento de consulta | search.py search() | Search.status:<br/>PRE_QUERY_PROCESSING | Processa `Search.query_string` e atualiza `Search.query_string_processed` |
| Federação | search.py search() | Search.status:<br/>FEDERATING<br/>FEDERATING_WAIT_*<br/>FULL_RESULTS | Cria um Conector para cada SearchProvider na pesquisa |
| Inicialização do Conector | connectors/connector.py<br/>connectors/db_connector.py | Connector.status:<br/>INIT<br/>READY | Carrega a Pesquisa e o SearchProvider | 
| Conector de Federação | federate() | Connector.status:<br/>FEDERATING |  |
| Processamento de consulta do Conector|  process_query() | FEDERATING | Processa `Search.query_string_processed` e armazena em `Connector.query_string_to_provider` |
| Construção da consulta do Conector | construct_query() | FEDERATING | Pega `Connector.query_string_to_provider` e cria `Connector.query_to_provider` |
| Validação da consulta do Conector | validate_query() | FEDERATING | Retorna "Falso" se `Connector.query_to_provider` estiver vazio |
| Execução da pesquisa do Conector | execute_search () | FEDERATING | Conecta-se ao SearchProvider<br/>Executa a pesquisa usando `Search.query_to_provider`<br/>Armazena a resposta em `Connector.response` | 
| Normalização da resposta do Conector | normalize_response() | FEDERATING | Transforma `Connector.response` em uma lista JSON de dicionários<br/>Armazena-a em `Connector.results` |
| Processamento de resultados do Conector | process_results() | Connector.status:<br/>FEDERATING<br/>READY | Processa `Connector.results` |
| Salvar Resultados do Conector | save_results() | Connector.status:<br/>READY | Retorna "Verdadeiro" |
| Processamento pós-resultados | search.py search() | Search.status:<br/>POST_RESULT_PROCESSING<br/>FULL_RESULTS_READY<br/>FULL_UPDATE_READY | Executa os `processadores de pós-resultados`<br/>Atualiza objetos de Resultado | 

<br/>

# `Search.Status`

## Estados Normais

| Status | Significado | 
| ---------- | ---------- |
| NEW_SEARCH | O objeto de pesquisa deve ser executado imediatamente |
| UPDATE_SEARCH | O objeto de pesquisa deve ser atualizado imediatamente |
| PRE_PROCESSING | O Swirl está realizando pré-processamento para esta pesquisa |
| PRE_QUERY_PROCESSING | O Swirl está realizando pré-processamento de consulta para esta pesquisa |
| FEDERATING | O Swirl está provisionando trabalhadores Celery com Conectores e esperando resultados |
| FEDERATING_WAIT_n | O Swirl está esperando pelo número de segundos indicado por `n` |
| FULL_RESULTS | O Swirl recebeu todos os resultados |
| NO_RESULTS | O Swirl não recebeu nenhum resultado |
| PARTIAL_RESULTS | O Swirl recebeu resultados de alguns provedores, mas não de todos |
| POST_RESULT_PROCESSING | O Swirl está realizando processamento pós-resultados |
| PARTIAL_RESULTS_READY | O Swirl processou resultados de provedores que responderam |
| PARTIAL_UPDATE_READY | O Swirl processou resultados atualizados de provedores que responderam  | 
| FULL_RESULTS_READY | O Swirl processou resultados de todos os provedores especificados  | 
| FULL_UPDATE_READY | O Swirl processou resultados atualizados de todos os provedores especificados | 

## Estados de Erro

| Status | Significado | 
| ---------- | ---------- |
| ERR_DUPLICATE_RESULT_OBJECTS | Mais de um objeto de Resultado foi encontrado; [entre em contato com o suporte](#support) para obter assistência. |
| ERR_NEED_PERMISSION | O Usuário Django não tinha permissões suficientes para executar a operação solicitada. Mais: [Permissões para Usuários Normais](3.-Guia-do-Administrador.md#permissões-para-usuários-normais) | 
| ERR_NO_ACTIVE_SEARCHPROVIDERS | A pesquisa falhou porque nenhum SearchProvider especificado estava ativo |
| ERR_NO_RESULTS | O Swirl não recebeu resultados de nenhuma fonte |
| ERR_NO_SEARCHPROVIDERS | A pesquisa falhou porque nenhum SearchProvider foi especificado |
| ERR_RESULT_NOT_FOUND | Um objeto de Resultado que se esperava encontrar não foi; [entre em contato com o suporte](#support) para obter assistência. |
| ERR_RESULT_PROCESSING | Ocorreu um erro durante o processamento de Resultado - verifique os `logs/celery-worker.log` para obter detalhes | 
| ERR_SUBSCRIBE_PERMISSIONS | O usuário que criou o objeto de pesquisa não possui permissões para habilitar o modo `subscribe` |

<br/>

# Lista de Módulos Principais

* ### [Controlador de Visualizações](https://github.com/swirlai/swirl-search/tree/main/swirl/views.py)
* ### [Fluxo de Trabalho de Pesquisa](https://github.com/swirlai/swirl-search/tree/main/swirl/search.py)
* ### [Conectores](https://github.com/swirlai/swirl-search/tree/main/swirl/connectors)
* ### [Processadores](https://github.com/swirlai/swirl-search/tree/main/swirl/processors)
* ### [Misturadores](https://github.com/swirlai/swirl-search/tree/main/swirl/mixers)
* ### [Transformações de Consulta](https://github.com/swirlai/swirl-search/tree/main/swirl/processors/transform_query_processor.py)

</br>



# Objeto SearchProvider

Um SearchProvider define alguma fonte pesquisável. Ele inclui metadados que identificam o tipo de conector usado para pesquisar a fonte e muito mais. Muitas propriedades são opcionais ao criar um objeto SearchProvider. Elas terão os valores padrão mostrados abaixo.

## Propriedades

| Propriedade | Descrição | Valor Padrão (`Exemplo`) | 
| ---------- | ---------- | ---------- |
| id | Identificador único para o SearchProvider | Automático (`1`) |
| name | Nome legível por humanos da fonte | "" (`"Enterprise Search PSE"`) |
| owner | O nome de usuário do usuário Django que é o proprietário do objeto | Usuário logado (`"admin"`) |
| shared | Configuração booleana: se `true`, o SearchProvider pode ser pesquisado por outros usuários; se `false`, está disponível apenas para o `owner` | true (`false`) |
| date_created | A data e hora em que o SearchProvider foi criado | Automático (`2022-02-28T17:55:04.811262Z`) |
| date_updated | A data e hora em que o SearchProvider foi atualizado | Automático (`2022-02-29T18:03:02.716456Z`) |
| active | Configuração booleana: se `true`, o SearchProvider é usado, se `false`, é ignorado ao federar | false (`true`) |
| default | Configuração booleana: se `true`, o SearchProvider será consultado para pesquisas que não especificam uma `searchprovider_list`; se `false`, o SearchProvider deve ser especificado na `searchprovider_list` | false (`true`) |
| connector | Nome do conector a ser usado para esta fonte | "" (`"RequestsGet"`) | 
| url | A URL ou outra string, incluindo o caminho do arquivo necessário pelo conector para esta fonte; não validado | "" (`"https://www.googleapis.com/customsearch/v1"`) |
| query_template | Uma string com variáveis opcionais no formato `{variável}`; o conector vinculará o `query_template` com os dados necessários, incluindo `url` e `query_string`, bem como quaisquer `query_mappings` ou `credentials`, em tempo de execução. Observe que este formato ainda não é usado pelo [Conector Sqlite3](#sqlite3). | "" (`"{url}?q={query_string}"`) |
| post_query_template | Para o Conector RequestsPost: JSON válido e um marcador para o texto da consulta que será enviado como corpo POST | "" (`"query": "{query_string}","limit": "100"`) |
| http_request_headers | Uma string para passar valores personalizados de cabeçalho de solicitação HTTP para a fonte junto com a consulta| "" (`"Accept": "application/vnd.github.text-match+json"`) |
| query_processors | Uma lista de processadores a serem usados para preparar a consulta para esta fonte | "" (`"AdaptiveQueryProcessor"`) |
| query_mappings | Uma string que define as correspondências para a consulta. Dependente do conector usado. | "" (`"cx=your-google-search-engine-key"`) |
| result_grouping_field | Usado com o processador de resultados `DedupeByFieldResultProcessor`, esta string define o campo de origem específico a ser usado para supressão de duplicados. | "" (`"resource.conversationId"`) |
| result_processors | Uma lista de processadores a serem usados para normalizar os resultados desta fonte | "CosineRelevancyResultProcessor" (`"MappingResultProcessor","CosineRelevancyResultProcessor"`) |
| response_mappings | Lista de chaves de resposta e caminhos JSON para transformar a resposta deste provedor em um conjunto de resultados JSON | "" (`"FOUND=searchInformation.totalResults, RETRIEVED=queries.request[0].count, RESULTS=items"`) |
| result_mappings | Lista de chaves, opcionalmente com valores; consulte [Guia do Usuário, Mapeamento de Resultados](2.-Guia-do-Usuário.md#opções-de-mapeamento-de-resultados) para notas sobre chaves especiais | "" (`"url=link,body=snippet,cacheId,NO_PAYLOAD"`) |
| results_per_query | O número de resultados a serem solicitados desta fonte para cada consulta | 10 (`20`) |
| credentials | As credenciais a serem usadas para esta fonte. Dependente da fonte. | "" (`"key=your-google-json-api-key"`) |
| eval_credentials | Uma variável de credencial definida na sessão e depois usada no SearchProvider. | "" (`"session["my-connector-token"]"`) |
| tags | Lista de strings que organizam os SearchProviders em grupos. | "" (`"Notícias", "BuscaEmpresarial"`) |

:warning: **A partir da versão 2.5, o `CosineRelevancyResultProcessor` revisado deve ser adicionado por último na lista de `result_processors`.

## APIs

| URL | Explicação |
| ---------- | ---------- |
| /swirl/searchproviders/      | Listar objetos SearchProvider, mais recentes primeiro; crie um novo usando o botão POST e o formulário na parte inferior |
| /swirl/searchproviders/id/ | Recuperar um objeto SearchProvider específico; destruí-lo usando o botão DELETE; editá-lo usando o botão PUT e o formulário na parte inferior  |

</br>

# Objeto de Pesquisa

Os objetos de pesquisa são dicionários JSON que definem as pesquisas que algum usuário ou sistema deseja executar. Eles têm IDs exclusivos. Eles podem ser vinculados a objetos de Resultado.

A única propriedade obrigatória é uma `query_string` com o texto real a ser pesquisado. Todas as outras propriedades são opcionais ao criar um objeto de pesquisa, e elas terão os valores padrão mostrados abaixo. Conforme o Swirl executa uma pesquisa, de forma assíncrona, ele atualizará propriedades do objeto de pesquisa como `status` e `result_url` em tempo real.

## Propriedades

| Propriedade | Descrição | Valor Padrão (`Exemplo`) | 
| ---------- | ---------- | ---------- |
| id | Identificador único para a pesquisa | Automático (`search_id=1`) |
| owner | O nome de usuário do usuário Django que é o proprietário do objeto | Usuário logado (`admin`) |
| date_created | A data e hora em que a pesquisa foi criada | Automático (`2022-02-28T17:55:04.811262Z`) |
| date_updated | A data e hora em que a pesquisa foi atualizada | Automático (`2022-02-28T17:55:07.811262Z`) |
| query_string | A consulta a ser federada - o único campo obrigatório! | "" (`gerenciamento de conhecimento`) | 
| query_string_processed | A consulta de pesquisa, modificada por qualquer pré-processamento da consulta | "" ("") |
| sort | O tipo de pesquisa a ser executado | relevância (`data`) | 
| results_requested | O número de resultados, no geral, que o usuário solicitou | 10 (`25`) | 
| searchprovider_list | Uma lista de SearchProviders para pesquisar esta consulta; uma lista vazia, o padrão, pesquisa todas as fontes | [] (`[ "Motores de Busca Empresariais - Google PSE" ]`) |
| subscribe | Se `True`, o Swirl atualizará esta pesquisa conforme o agendamento do Celery-Beats | False (`True`) |
| status | O status de execução desta pesquisa (veja abaixo) | NEW_SEARCH (`FULL_RESULTS_READY`) |
| pre_query_processors | Uma lista de processadores a serem aplicados à consulta antes de iniciar a federação | "" (`[ "SpellcheckQueryProcessor" ]`) |
| post_result_processors | Uma lista de processadores de resultados a serem aplicados aos resultados após a conclusão da federação | "" (`[ "DedupeByFieldPostResultProcessor", "CosineRelevancyPostResultProcessor" ]`) |
| result_url | Link para o objeto de Resultado inicial para a Pesquisa, que utiliza o `RelevancyMixer` | Automático (`"http://localhost:8000/swirl/results?search_id=17&result_mixer=RelevancyMixer"`) |
| new_result_url | Link para o objeto de Resultado atualizado para a pesquisa, que utiliza o `RelevancyNewItemsMixer` | Automático (`"http://localhost:8000/swirl/results?search_id=17&result_mixer=RelevancyNewItemsMixer"`) | 
| messages | Mensagens dos SearchProviders | "" (`Recuperado 1 de 1 resultados de: Document DB Search`) | 
| result_mixer | O nome do objeto Mixer (veja abaixo) a ser usado para ordenar resultados | RoundRobinMixer (`Stack2Mixer`) | 
| retention | A configuração de retenção para este objeto; `0` = reter indefinidamente; consulte [Serviço de Expiração de Pesquisa](3.-Guia-do-Administrador.md#serviço-de-expiração-de-pesquisa) para obter detalhes | 0 (`2` para exclusão diária) | 
| tags | Parâmetro (string) que pode ser passado em uma pesquisa e será anexado ao objeto de Pesquisa armazenado no Swirl | "" (`{ "query_string": "gerenciamento de conhecimento", "tags": ["max_length:50"] }`) | 

:key: Existem algumas tags especiais de Pesquisa que controlam o processamento de consultas. Por exemplo, a tag de Pesquisa `SW_RESULT_PROCESSOR_SKIP` pode ser usada para pular um processador para a Pesquisa para a qual é especificada: `SW_RESULT_PROCESSOR_SKIP:DedupeByFieldResultProcessor`


## APIs

| URL | Explicação |
| ---------- | ---------- |
| /swirl/search/ | Listar objetos de Pesquisa, os mais recentes primeiro; crie um novo usando o formulário na parte inferior e o botão POST |
| /swirl/search/id/ | Recuperar um objeto de Pesquisa específico; destruí-lo usando o botão DELETE; editá-lo usando o formulário na parte inferior e o botão PUT |
| /swirl/search/?q=some+query | Criar um objeto de Pesquisa com valores padrão, exceto para `query_string`, que é definido com o valor do parâmetro `q=`; redireciona para o conjunto de resultados; também aceita o parâmetro `providers` |
| /swirl/search/?qs=some+query | Criar um objeto de Pesquisa como acima, mas retornar resultados de forma síncrona; também aceita os parâmetros `providers` e `result_mixer` |
| /swirl/search/?rerun=id | Re-executar uma Pesquisa, excluindo quaisquer Resultados armazenados anteriormente |
| /swirl/search/?update=id | [Atualizar uma Pesquisa](5.-Guia-do-Desenvolvedor.md#atualizar-uma-pesquisa) com novos resultados desde a última vez que você a executou |

<br/>

# Objetos de Resultado

Um objeto de Resultado é o resultado normalizado e reclassificado para uma única Pesquisa, de um único SearchProvider. Eles são criados no final do processo de pesquisa federada em resposta à criação de um objeto de Pesquisa. Eles são o único objeto Swirl que possui uma chave estrangeira (`search.id`).

Somente os Conectores devem criar objetos de Resultado.

Os desenvolvedores são livres para operar em Resultados individuais conforme necessário para sua aplicação.

No entanto, o objetivo do Swirl (e da pesquisa federada em geral) é fornecer resultados unificados de todas as fontes. O Swirl usa Mixers para tornar isso rápido e fácil.

## Propriedades

| Propriedade | Descrição | `Exemplo` | 
| ---------- | ---------- | ---------- | 
| id | Identificador único para o Resultado | `1` |
| owner | O nome de usuário do usuário Django que é o proprietário do objeto | `admin` |
| date_created | A data e hora em que o Resultado foi criado. | `2022-02-28T17:55:04.811262Z` |
| date_updated | A data e hora em que o Resultado foi atualizado | `2022-02-28T19:55:02.752962Z` |
| search_id | O `id` da Pesquisa associada; pode haver muitos objetos de Resultado com este `id` | `18` | 
| searchprovider | O valor do nome do SearchProvider que forneceu esta lista de resultados | `"OneDrive Files - Microsoft 365"` |
| query_to_provider | A consulta exata enviada ao SearchProvider | `https://www.googleapis.com/customsearch/v1?cx=google-search-engine-id&key=google-json-api-key&q=strategy` |
| query_processors | Os nomes dos Processadores, especificados no SearchProvider, que processaram a consulta | `"AdaptiveQueryProcessor"` |
| result_processors | Os nomes dos Processadores, especificados no SearchProvider, que normalizaram os resultados | `"MappingResultProcessor","CosineRelevancyResultProcessor"` |
| result_processor_json_feedback | A ser determinado | (*Veja um objeto de Resultado completo*) |
| messages | Uma lista de mensagens (strings) do SearchProvider | `Recuperado 10 de 249 resultados de: OneDrive Files - Microsoft 365` |
| status | A prontidão do conjunto de resultados | `READY` |
| retrieved | O número de resultados recuperados pelo Swirl deste SearchProvider para esta consulta | `10` |
| found | O número total de resultados relatados pelo SearchProvider para esta consulta | `2309` |
| time | O tempo que o SearchProvider levou para criar este conjunto de resultados, em segundos | `1.9` |
| json_results | Os resultados JSON normalizados deste SearchProvider | (*Veja abaixo*) | 

## json_results

| Campo | Descrição | Exemplo |
| ---------- | ---------- | ---------- |
| swirl_rank | Classificação de relevância do Swirl para este resultado | `1` |
| swirl_score | Uma métrica que mostra a relevância do resultado para a consulta. Não se destina a ser significativa como número de outra forma. É mostrado apenas se [&explain=True](5.-Guia-do-Desenvolvedor.md#entenda-a-estrutura-de-explicação) estiver definido. | `1890.6471312936828` |
| searchprovider | Nome legível por humanos do SearchProvider | `"OneDrive Files - Microsoft 365"` |
| searchprovider_rank | A classificação do SearchProvider deste resultado | `3`
| title | Título relatado pela fonte para este resultado, com correspondências de termos de pesquisa destacadas | `Indústria de carros alemã investirá em <em>veículos</em> <em>elétricos</em> ...` |
| url | URL para este resultado; pode ser relatado pela fonte e/ou calculado pelo Swirl | `http://pwc.com/etc` |
| body | Trechos de resultados relatados pela fonte, com correspondências de termos de pesquisa destacadas | `<em>Tecnologia</em> estratégia abrange um conjunto completo de capacidades de Consultoria ...` |
| date_published | A data e hora de publicação relatada pela fonte para este resultado, quando disponível (`desconhecido` se não). Este é o campo usado pelo [DateMixer](#mixers-1) | `desconhecido` |
| date_published_display | Campo opcional do SearchProvider para mapear um valor de data de publicação diferente para fins de exibição. | `... date_published=foo.bar.date1,date_published_display=foo.bar.date2 ...` |
| date_retrieved | A data e hora em que o Swirl recebeu este resultado da fonte | `2022-02-20 03:45:03.207909` |
| author | Autor relatado pela fonte deste resultado, quando disponível | `"CNN staff"` |
| title_hit_highlights | A ser determinado | A ser determinado |
| body_hit_highlights | A ser determinado | A ser determinado |
| payload | Um dicionário de todas as chaves restantes na resposta do SearchProvider | `{}` |
| explain | Um dicionário que contém (a) os radicais de palavras correspondentes, (b) pontuações de similaridade para cada correspondência em cada campo, (c) ajustes de comprimento e outras metadados, (d) informações de `hits`. É mostrado apenas se [&explain=True](5.-Guia-do-Desenvolvedor.md#entenda-a-estrutura-de-explicação) estiver definido. | `{}` |

:key: Observe que PAYLOAD pode ser totalmente diferente de um SearchProvider para outro. Cabe ao chamador acessar o PAYLOAD e extrair o que for necessário, geralmente criando um novo Processador (consulte abaixo) ou adicionando `result_mappings`.

## APIs

| URL | Explicação |
| ---------- | ---------- |
| /swirl/results/ | Listar objetos de Resultado, os mais recentes primeiro; crie um novo usando o botão POST e o formulário na parte inferior |
| /swirl/results/id/ | Recuperar um objeto de Resultado específico; destruí-lo usando o botão DELETE; editá-lo usando o botão PUT e o formulário na parte inferior |
| /swirl/results/?search_id=search_id | Recuperar Resultados unificados para uma Pesquisa específica, ordenados pelo Mixer especificado; também aceita os parâmetros `result_mixer` e `page` |

# Conectores

Os Conectores são objetos responsáveis por pesquisar um tipo específico de SearchProvider, recuperar os resultados e normalizá-los para o formato Swirl. Isso inclui a chamada de processadores de consulta e de resultados.

Tanto [`connector.py`](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/connector.py) quanto [`db_connectory.py`](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/db_connector.py) são classes base das quais outras classes de conector são derivadas.  Enquanto [`requests.py`](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/requests.py) é um invólucro chamado por `RequestsGet`. Duas funções de utilidade, [`mappings.py`](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/mappings.py) e [`utils.py`](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/utils.py), podem ser usadas por outros Conectores.

:key: Para a versão 2.5.1, [`requests.py`](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/requests.py) foi atualizado para lidar com respostas XML das APIs de origem e convertê-las em JSON para mapeamento nas configurações do SearchProvider.

A tabela a seguir descreve os Conectores de origem incluídos:

| Conector | Descrição | Entradas |
| ---------- | ---------- | ---------- |
| BigQuery | Pesquisa no Google BigQuery | `query_template`, `credentials` (arquivo JSON de token de projeto) |
| ChatGPT | Pergunta ao OpenAI ChatGPT | `credentials` |
| Elastic | Pesquisa no Elasticsearch | `url` ou `cloud_id`, `query_template`, `index_name`, `credentials` |
| Microsoft Graph | Usa a API Microsoft Graph para pesquisar conteúdo M365 | `credentials` |
| OpenSearch | Pesquisa no OpenSearch | `url`, `query_template`, `index_name`, `credentials` |
| PostgreSQL | Pesquisa em bancos de dados PostgreSQL | `url` (parâmetros de conexão), `query_template`, `credentials` |
| RequestsGet | Pesquisa qualquer ponto de extremidade da web usando HTTP/GET com resposta JSON, incluindo Google PSE, SOLR, Northern Light e outros (consulte abaixo) | `url`, `credentials` |
| RequestsPost | Pesquisa qualquer ponto de extremidade da web usando HTTP/POST com resposta JSON, incluindo M365 | `url`, `credentials` |
| Sqlite3 | Pesquisa bancos de dados SQLite3 | `url` (caminho do arquivo do banco de dados), `query_template` |

Os Conectores são especificados e configurados em objetos de SearchProvider.

## BigQuery

O [conector BigQuery](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/bigquery.py) utiliza o pacote Google Cloud Python.

O [SearchProvider BigQuery](https://github.com/swirlai/swirl-search/blob/main/SearchProviders/funding_db_bigquery.json) incluído destina-se a ser usado com o [Conjunto de Dados de Financiamento](#conjunto-de-dados-de-financiamento), mas pode ser adaptado para a maioria das configurações.

``` shell
{
    "name": "Registros de Financiamento de Empresas - BigQuery",
    "active": false,
    "default": false,
    "connector": "BigQuery",
    "query_template": "selecione {fields} de `{table}` where search({field1}, '{query_string}') ou search({field2}, '{query_string}');",
    "query_processors": [
        "AdaptiveQueryProcessor"
    ],
    "query_mappings": "fields=*,sort_by_date=fundedDate,table=funding.funding,field1=company,field2=city",
    "result_processors": [
        "MappingResultProcessor",	
        "CosineRelevancyResultProcessor"
    ],
    "result_mappings": "title='{company}',body='{company} levantou ${raisedamt} série {round} em {fundeddate}. A empresa está localizada em {city} {state} e tem {numemps} funcionários.',url=permalink,date_published=fundeddate,NO_PAYLOAD",
    "credentials": "/caminho/para/bigquery/token.json",
    "tags": [
        "Empresa",
        "BigQuery"
    ]
}
```

Mais informações: [Documentação do BigQuery](https://cloud.google.com/bigquery/docs)

## ChatGPT

:star: Para a versão 2.5.1, tanto o [`Conector`](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/chatgpt.py) quanto o [`QueryProcessor`](https://github.com/swirlai/swirl-search/blob/main/swirl/processors/chatgpt_query.py) do ChatGPT foram atualizados para usar o método [`ChatCompletion`](https://platform.openai.com/docs/api-reference/chat) que suporta os modelos GPT mais recentes, incluindo `GPT-4`, e uma gama muito maior de interatividade. O ChatGPT SearchProvider agora faz consultas no modelo `GPT-3.5-Turbo` por padrão.

O [Conector ChatGPT](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/chatgpt.py) faz uso das APIs da OpenAI. Ele retornará no máximo um resultado.

As respostas do ChatGPT geralmente têm uma classificação alta, uma vez que são escritas sob demanda em resposta à consulta do usuário, refletem a terminologia associada a essa consulta e são intituladas de acordo com a consulta.

O [SearchProvider incluído](https://github.com/swirlai/swirl-search/blob/main/SearchProviders/chatgpt.json) está pré-configurado com um prompt "Fale-me sobre: ...". O [`ChatGPTQueryProcessor`](https://github.com/swirlai/swirl-search/blob/main/swirl/processors/chatgpt_query.py) também contém outras opções de consulta para o ChatGPT.

``` shell
{
    "name": "ChatGPT - OpenAI",
    "active": false,
    "default": true,
    "connector": "

ChatGPT",
    "url": "",
    "query_template": "",
    "query_processors": [
        "AdaptiveQueryProcessor"
    ],
    "query_mappings": "PROMPT='Fale-me sobre: {query_to_provider}'",
    "result_processors": [
        "GenericResultProcessor",
        "CosineRelevancyResultProcessor"
    ],
    "response_mappings": "",
    "result_mappings": "BLOCK=ai_summary",
    "results_per_query": 10,
    "credentials": "sua-chave-de-API-openai-aqui",
    "tags": [
        "ChatGPT",
        "Pergunta"
    ]
}
```

As Tags `Pergunta` e `ChatGPT` do SearchProvider facilitam a segmentação do ChatGPT, iniciando uma consulta com qualquer uma delas. Por exemplo:

``` shell
Pergunta: Fale-me sobre software de gestão do conhecimento?
```

:warning: Você deve remover o valor padrão `result_mappings` de `BLOCK=ai_summary` na configuração do SearchProvider para habilitar as Tags `ChatGPT` ou `Pergunta`! Caso contrário, essas Tags serão ignoradas.

### Tags do SearchProvider do ChatGPT

As seguintes três Tags estão disponíveis para uso no SearchProvider do ChatGPT para ajudar a moldar o Prompt ou a Função Padrão passada ao ChatGPT, juntamente com a consulta do usuário. Para utilizar essas opções:
1. Adicione uma chave de API OpenAI válida ao arquivo `.env` do Swirl (encontrado no diretório `swirl-home`) e reinicie o Swirl para que ela tenha efeito.
2. Adicione o `ChatGPTQueryProcessor` à lista de query_processors do SearchProvider:

``` shell
    "query_processors": [
        "AdaptiveQueryProcessor",
        "ChatGPTQueryProcessor"
    ],
```


#### Tags Disponíveis

* `CHAT_QUERY_REWRITE_PROMPT`: Substitui o Prompt padrão usado para reescrever a consulta.
``` shell
"CHAT_QUERY_REWRITE_PROMPT:Escreva uma consulta mais precisa de tamanho semelhante a esta: {query_string}"
```

* `CHAT_QUERY_REWRITE_GUIDE`: Substitui a função padrão passada para o ChatGPT.
``` shell
"CHAT_QUERY_REWRITE_GUIDE:Você é um assistente prestativo que responde como um capitão pirata"
```

* `CHAT_QUERY_DO_FILTER`: Ativa ou desativa o filtro interno padrão das respostas do ChatGPT.
``` shell
"CHAT_QUERY_DO_FILTER:falso"
```

### Mapeamento de Consulta do ChatGPT

O seguinte mapeamento de consulta `query_mapping` também está disponível para uso no SearchProvider do ChatGPT para ajudar a moldar a Função Padrão passada ao ChatGPT juntamente com a consulta do usuário. Para utilizar este `query_mapping`, adicione uma chave de API OpenAI válida ao arquivo `.env` do Swirl (encontrado no diretório `swirl-home`) e depois reinicie o Swirl para que tenha efeito.

* `CHAT_QUERY_REWRITE_GUIDE`: Substitui a função `system` passada ao ChatGPT.
``` shell
"query_mappings": "PROMPT='Me conte sobre: {query_to_provider}',CHAT_QUERY_REWRITE_GUIDE='Você é um assistente prestativo que responde como um capitão pirata'",
```

## Elastic & OpenSearch

Os Conectores [Elastic](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/elastic.py) e [OpenSearch](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/opensearch.py) fazem uso do cliente Python de cada mecanismo.

Aqui está um exemplo de um SearchProvider para se conectar ao ElasticCloud usando o `cloud_id`:

``` shell
{
    "name": "E-mails ENRON - Elastic Cloud",
    "connector": "Elastic",
    "url": "seu-cloud-id-aqui",
    "query_template": "índice='{index_name}', consulta={'query_string': {'query': '{query_string}', 'default_field': '{default_field}'}}",
    "query_processors": [
        "AdaptiveQueryProcessor"
    ],
    "query_mappings": "index_name=email,default_field=content,sort_by_date=date_published.keyword,NOT=true,NOT_CHAR=-",
    "result_processors": [
        "MappingResultProcessor",
        "CosineRelevancyResultProcessor"
    ],
    "result_mappings": "url=_source.url,date_published=_source.date_published,author=_source.author,title=_source.subject,body=_source.content,_source.to,NO_PAYLOAD",
    "credentials": "(\"elastic\", \"senha-elastic\")",
    "tags": [
        "Enron",
        "Elastic"
    ]
}
```

Este é o SearchProvider padrão do OpenSearch que se conecta a uma instância local do mecanismo:

``` shell
{
    "name": "E-mails ENRON - OpenSearch",
    "active": false,
    "default": false,
    "connector": "OpenSearch",
    "url": "http://localhost:9200/",
    "query_template": "{\"query\":{\"query_string\":{\"query\":\"{query_string}\",\"default_field\":\"{default_field}\",\"default_operator\":\"e\"}}}",
    "query_processors": [
        "AdaptiveQueryProcessor"
    ],
    "query_mappings": "index_name=email,default_field=content,sort_by_date=date_published.keyword,NOT=true,NOT_CHAR=-",
    "result_processors": [
        "MappingResultProcessor",
        "CosineRelevancyResultProcessor"
    ],
    "result_mappings": "url=_source.url,date_published=_source.date_published,author=_source.author,title=_source.subject,body=_source.content,_source.to,NO_PAYLOAD",
    "credentials": "'admin','senha'",
    "tags": [
        "Enron",
        "OpenSearch"
    ]
}
```

Observe o uso de JSONPaths no `result_mappings`. Isso é essencial para Elastic e OpenSearch, pois eles incorporam resultados em um campo `_source`, a menos que seja configurado de outra forma. Para obter mais detalhes, consulte a seção [User Guide, Result Mappings](2.-User-Guide.md#result-mappings).

Use o campo [PAYLOAD](2.-User-Guide.md#payload-field) para armazenar conteúdo extra que não se ajusta a um item existente.

## Microsoft Graph

O [conector do Microsoft Graph](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/microsoft_graph.py) usa a API Microsoft Graph para consultar o conteúdo do M365. O usuário deve autenticar-se por meio do OAuth2 para permitir a pesquisa de seu conteúdo M365.

Existem 5 SearchProviders pré-configurados para consultar o conteúdo M365 do usuário autenticado:
* Mensagens do Outlook
* Eventos de Calendário
* Arquivos do OneDrive
* Sites do SharePoint
* Conversas do Teams

``` shell
{
        "name": "Mensagens do Outlook - Microsoft 365",
        "active": false,
        "default": true,
        "connector": "M365OutlookMessages",
        "url": "",
        "query_template": "{url}",
        "query_processors": [
            "AdaptiveQueryProcessor"
        ],
        "query_mappings": "NOT=true,NOT_CHAR=-",
        "result_grouping_field": "conversationId",
        "result_processors": [
            "MappingResultProcessor",
            "DedupeByFieldResultProcessor",
            "CosineRelevancyResultProcessor"
        ],
        "response_mappings": "",
        "result_mappings": "title=resource.subject,body=summary,date_published=resource.createdDateTime,author=resource.sender.emailAddress.name,url=resource.webLink,resource.isDraft,resource.importance,resource.hasAttachments,resource.ccRecipients[*].emailAddress[*].name,resource.replyTo[*].emailAddress[*].name,NO_PAYLOAD",
        "results_per_query": 10,
        "credentials": "",
        "eval_credentials": "",
        "tags": [
            "Microsoft",
            "Email"
        ]
    }
```

## PostgreSQL

O [conector PostgreSQL](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/postgresql.py) utiliza o driver [psycopg2](https://pypi.org/project/psycopg2/).

### Instalando o Driver PostgreSQL

Para usar o PostgreSQL com o Swirl:

1. Instale o [PostgreSQL](https://www.postgresql.org/) 
2. Modifique o PATH do sistema para que o `pg_config` da distribuição do PostgreSQL seja executado a partir da linha de comando.
3. Instale o `psycopg2` usando o `pip`:

``` shell
pip install psycopg2
```

4. Descomente o Conector PostgreSQL nos seguintes módulos:

* [swirl.connectors.__init__.py](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/__init__.py)

``` shell
# descomente isto para habilitar o PostgreSQL
# from swirl.connectors.postgresql import PostgreSQL
```

* [swirl.models.py](https://github.com/swirlai/swirl-search/blob/main/swirl/models.py)

``` shell
    CONNECTOR_CHOICES = [
        ('RequestsGet', 'HTTP/GET retornando JSON'),
        ('Elastic', 'Elasticsearch Query String'),
        # Descomente a linha abaixo para habilitar o PostgreSQL
        # ('PostgreSQL', 'PostgreSQL'),
        ('BigQuery', 'Google BigQuery'),
        ('Sqlite3', 'Sqlite3')
    ]
```

5. Execute o setup do Swirl:

``` shell
python swirl.py setup
```

6. Reinicie o Swirl:

``` shell
python swirl.py restart
```

7. Adicione um SearchProvider PostgreSQL, semelhante ao fornecido com o [Funding Dataset](#funding-data-set).

Aqui está um exemplo de um SearchProvider básico usando PostgreSQL:

``` shell
{
    "name": "Registros de Financiamento de Empresas - PostgreSQL",
    "default": false,
    "connector": "PostgreSQL",
    "url": "host:port:database:username:password",
    "query_template": "selecione {fields} de {table} where {field1} ilike '%{query_string}%' or {field2} ilike '%{query_string}%';",
    "query_processors": [
        "AdaptiveQueryProcessor"
    ],
    "query_mappings": "fields=*,sort_by_date=fundedDate,table=funding,field1=city,field2=company",
    "result_processors": [
        "MappingResultProcessor",
        "CosineRelevancyResultProcessor"
    ],
    "result_mappings": "title='{company} série {round}',body='{city} {fundeddate}: {company} arrecadou US$ {raisedamt}\nA empresa tem sede em {city} e emprega {numemps}',date_published=fundeddate,NO_PAYLOAD",
    "tags": [
        "Empresa"
    ]
}
```

Observação: Colocar uma consulta SQL fixa no `query_template` é perfeitamente aceitável. Qualquer coisa que não mude na URL pode ser armazenada aqui.

## RequestsGet

O [conector RequestsGet](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/requestsget.py) usa HTTP/GET para buscar URLs. Ele suporta autenticação opcional. Aqui está um SearchProvider genérico baseado no RequestsGet:

``` shell
{
    "name": "Exemplo de Ponto de Extremidade HTTP GET",
    "connector": "RequestsGet",
    "url": "http://hostname/site/endpoint",
    "query_template": "{url}&textQuery={query_string}",
    "query_processors": [
        "AdaptiveQueryProcessor"
    ],
    "query_mappings": "PAGE=start=RESULT_INDEX,DATE_SORT=sort=date",
    "result_processors": [
        "MappingResultProcessor",
        "CosineRelevancyResultProcessor"
    ],
    "response_mappings": "FOUND=count,RESULTS=results",
    "result_mappings": "body=content,date_published=date,author=creator",
    "credentials": "HTTPBasicAuth('seu-nome-de-usuário-aqui', 'sua-senha-aqui')",
    "tags": [
        "Notícias"
    }
}
```

Aqui está o mesmo conector, configurado para três Google Programmable Search Engines diferentes:

``` shell
[
    {
        "name": "Mecanismos de Busca Empresarial - Google PSE",
        "connector": "RequestsGet",
        "url": "https://www.googleapis.com/customsearch/v1",
        "query_template": "{url}?cx={cx}&key={key}&q={query_string}",
        "query_processors": [
            "AdaptiveQueryProcessor"
        ],
        "query_mappings": "cx=0c38029ddd002c006,DATE_SORT=sort=date,PAGE=start=RESULT_INDEX,NOT_CHAR=-",
        "result_processors": [
            "MappingResultProcessor",
            "DateFinderResultProcessor",
            "CosineRelevancyResultProcessor"
        ],
        "response_mappings": "FOUND=searchInformation.totalResults,RETRIEVED=queries.request[0].count,RESULTS=items",
        "result_mappings": "url=link,body=snippet,author=displayLink,cacheId,pagemap.metatags[*].['og:type'],pagemap.metatags[*].['og:site_name'],pagemap.metatags[*].['og:description'],NO_PAYLOAD",
        "credentials": "key=AIzaSyDvVeE-L6nCC9u-TTGuhggvSmzhtiTHJsA",
        "tags": [
            "Notícias",
            "BuscaEmpresarial"
        ]
    },
    {
        "name": "Consultoria Estratégica - Google PSE",
        "connector": "RequestsGet",
        "url": "https://www.googleapis.com/customsearch/v1",
        "query_template": "{url}?cx={cx}&key={key}&q={query_string}",
        "query_processors": [
            "AdaptiveQueryProcessor"
        ],
        "query_mappings": "cx=7d473806dcdde5bc6,DATE_SORT=sort=date,PAGE=start=RESULT_INDEX,NOT_CHAR=-",
        "result_processors": [
            "MappingResultProcessor",
            "DateFinderResultProcessor",
            "CosineRelevancyResultProcessor"
        ],
        "response_mappings": "FOUND=searchInformation.totalResults,RETRIEVED=queries.request[0].count,RESULTS=items",
        "result_mappings": "url=link,body=snippet,author=pagemap.metatags[*].['authors-name'],cacheId,pagemap.metatags[*].['articletype'],pagemap.metatags[*].['practice-name'],pagemap.metatags[*].['searchresults-tags'],pagemap.metatags[*].['site_name'],pagemap.metatags[*].['twitter:description'],NO_PAYLOAD",
        "credentials": "key=AIzaSyDvVeE-L6nCC9u-TTGuhggvSmzhtiTHJsA",
        "tags": [
            "Notícias",
            "ConsultoriaEstratégica"
        ]
    },
    {
        "name": "Fusões e Aquisições - Google PSE",
        "connector": "RequestsGet",
        "url": "https://www.googleapis.com/customsearch/v1",
        "query_template": "{url}?cx={cx}&key={key}&q={query_string}",
        "query_processors": [
            "AdaptiveQueryProcessor"
        ],
        "query_mappings": "cx=b384c4e79a5394479,DATE_SORT=sort=date,PAGE=start=RESULT_INDEX

,NOT_CHAR=-",
        "result_processors": [
            "MappingResultProcessor",
            "DateFinderResultProcessor",
            "CosineRelevancyResultProcessor"
        ],
        "response_mappings": "FOUND=searchInformation.totalResults,RETRIEVED=queries.request[0].count,RESULTS=items",
        "result_mappings": "url=link,body=snippet,author=pagemap.metatags[*].['article:publisher'],cacheId,pagemap.metatags[*].['og:type'],pagemap.metatags[*].['article:tag'],pagemap.metatags[*].['og:site_name'],pagemap.metatags[*].['og:description'],NO_PAYLOAD",
        "credentials": "key=AIzaSyDvVeE-L6nCC9u-TTGuhggvSmzhtiTHJsA",
        "tags": [
            "Notícias",
            "FusõesAquisições"
        ]
    }
]
```

E aqui está novamente, configurado para o SOLR com a [coleção de exemplos de produtos de tecnologia](https://solr.apache.org/guide/solr/latest/getting-started/tutorial-techproducts.html) instalada:

``` shell
{
    "name": "techproducts - Apache Solr",
    "active": false,
    "default": false,
    "connector": "RequestsGet",
    "url": "http://localhost:8983/solr/{collection}/select?wt=json",
    "query_template": "{url}&q={query_string}",
    "query_processors": [
        "AdaptiveQueryProcessor"
    ],
    "query_mappings": "collection=techproducts,PAGE=start=RESULT_ZERO_INDEX,NOT=True,NOT_CHAR=-",
    "result_processors": [
        "MappingResultProcessor",
        "CosineRelevancyResultProcessor"
    ],
    "response_mappings": "FOUND=numFound,RESULTS=response.docs",
    "result_mappings": "title=name,body=features,response",
    "credentials": "",
    "tags": [
        "Produtos",
        "Solr"
    ]
}
```

Para adaptar o RequestsGet para a sua resposta JSON, basta substituir os JSONPaths à direita das configurações FOUND, RETRIEVED e RESULT em `response_mappings`, seguindo o formato da esquerda para a direita de `swirl_key=source-key`. Se a resposta fornecer um invólucro de dicionário em torno de cada resultado, use o caminho RESULT para extrair isso.

A partir daí, mapeie os campos dos resultados para o esquema do Swirl, conforme descrito na seção [User Guide, Result Mapping](2.-User-Guide.md#result-mappings). Use o [PAYLOAD Field](2.-User-Guide.md#payload-field) para armazenar qualquer conteúdo extra de SearchProviders que não se ajuste a um campo existente do Swirl.

Adicione parâmetros `chave/valor` adicionais necessários à `url` - se eles não mudarem de SearchProvider para SearchProvider - ou adicionando um mapeamento no `query_template` e um valor padrão ou orientação no `query_mappings`. (Veja `{collection}` no exemplo do SOLR acima.)

## RequestsPost

O [conector RequestsPost](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/requestspost.py) usa HTTP/POST para enviar formulários de pesquisa para URLs configuradas. Ele suporta autenticação opcional. O RequestsPost é usado pelos conectores M365 e agora está disponível para outras fontes. Aqui está um SearchProvider genérico baseado no RequestsPost:

``` shell
{
    "name": "Exemplo de Ponto de Extremidade HTTP POST",
    "active": false,
    "default": false,
    "connector": "RequestsPost",
    "url": "https://xx.apis.it.h.edu/ats/person/v3/search",
    "query_template": "{url}?Query={query_string}",
    "query_processor": "",
    "post_query_template": {
        "fields": [
          "names.personNameKey",
          "names.firstName",
          "names.lastName"
        ],
        "conditions": {
          "names.name": "*{query_string}*"
        }
    },
    "query_processors": [
        "AdaptiveQueryProcessor"
    ],
    "query_mappings": "NOT=true,NOT_CHAR=-",
    "result_processor": "",
    "result_processors": [
        "MappingResultProcessor",
        "CosineRelevancyResultProcessor"
    ],
    "response_mappings": "FOUND=count,RESULTS=results",
    "result_mappings": "titles=names[0].name,url=names[0].personNameKey,body='{names[0].name} ID#: {names[*].personNameKey}'",
    "results_per_query": 10,
    "credentials": "X-Api-Key=<sua-chave-api>",
    "eval_credentials": "",
    "tags": [
        "Pessoas"
    ]
}
```

[Entre em contato com o suporte](#support) para obter ajuda para começar.

## SQLite3

O [conector SQLite3](https://github.com/swirlai/swirl-search/blob/main/swirl/connectors/sqlite3.py) utiliza o driver SQLite3 incorporado no Python.

Aqui está um exemplo de um SearchProvider usando SQLite3:

``` shell
{
    "name": "Registros de Financiamento de Empresas - SQLite3",
    "active": false,
    "default": false,
    "connector": "Sqlite3",
    "url": "db.sqlite3",
    "query_template": "selecione {fields} de {table} where {field1} like '%%{query_string}%%' or {field2} like '%%{query_string}%%';",
    "query_processors": [
        "AdaptiveQueryProcessor"
    ],
    "query_mappings": "fields=*,sort_by_date=fundeddate,table=funding,field1=city,field2=company",
    "result_processors": [
        "MappingResultProcessor",
        "CosineRelevancyResultProcessor"
    ],
    "result_mappings": "title='{company} série {round}',body='{city} {fundeddate}: {company} arrecadou US$ {raisedamt}\nA empresa tem sede em {city} e emprega {numemps}',date_published=fundeddate,NO_PAYLOAD",
    "tags": [
        "Empresa"
    ]
}
```

Observação: Colocar uma consulta SQL fixa no `query_template` é perfeitamente aceitável. Qualquer coisa que não mude na URL pode ser especificada aqui.

<br/>

# Pipelines de Processamento

![Swirl Processing Pipelines](../images/processing_pipielines.png)

Os Processadores são destinados a ter um único propósito e são executados em uma sequência chamada "pipeline". Os pipelines são especificados como listas JSON em suas respectivas propriedades. Existem quatro pipelines de processamento no Swirl:
* `Search.pre_query_processors`
* `SearchProvider.query_processors`
* `SearchProvider.result_processors`
* `Search.post_result_processors`

Por exemplo, o pipeline padrão `Search.post_result_processors` é o seguinte:

``` shell
"post_result_processors": [
            "DedupeByFieldPostResultProcessor",
            "CosineRelevancyPostResultProcessor"
        ],
```

Este pipeline remove duplicatas do conjunto de resultados antes da classificação de relevância.

## Processadores de Consulta

Os Processadores de Consulta operam consultas. O campo exato em que eles operam depende de como são implantados.

Aqui estão as informações sobre os pipelines de processamento e os processadores de consulta, processadores de resultado e processadores pós-resultado incluídos no Swirl:

| Pipeline | Lê | Atualizações |
| ---------- | ---------- | ---------- | 
| Search.pre_query_processors | `Search.query_string` | `Search.query_string_processed` | 
| SearchProvider.query_processors | `Search.query_string_processed` | `<Connector>.query_string_to_provider` | 

Esta tabela descreve os processadores de consulta incluídos no Swirl:

| Processador | Descrição | Notas | 
| ---------- | ---------- | ---------- | 
| AdaptiveQueryProcessor | Reconstrói consultas com base nas `query_mappings` de um SearchProvider específico | Não deve ser usado como `pre_query_processor` |
| ChatGPTQueryProcessor | Descrição atualizada a ser determinada | Experimental |
| GenericQueryProcessor | Remove caracteres especiais da consulta |  |
| SpellcheckQueryProcessor | Usa o [TextBlob](https://textblob.readthedocs.io/en/dev/quickstart.html#spelling-correction) para prever e corrigir erros de ortografia em `query_string` | Melhor implantado em um `SearchProvider.query_processor` para fontes que precisam disso; não recomendado com Google PSEs |

## Processadores de Resultado

Os processadores de resultado transformam os resultados da fonte no formato Swirl definido em [swirl/processors/utils.py](https://github.com/swirlai/swirl-search/blob/main/swirl/processors/utils.py).

A tabela a seguir lista os processadores de resultado incluídos no Swirl:

| Processador | Descrição | Notas | 
| ---------- | ---------- | ---------- | 
| GenericResultProcessor | Copia resultados do formato da fonte para o formato Swirl por correspondência exata no nome | Recomendado para fontes que não precisam de mapeamento |
| MappingResultProcessor | Transforma resultados do formato da fonte para o formato Swirl, usando `SearchProvider.result_mappings` | Padrão |
| LenLimitingResultProcessor | Verifica se as respostas de `title` e `body` da fonte excedem um comprimento configurável (definido em `swirl_server/settings.py`: `SWIRL_MAX_FIELD_LEN = 512`), trunca qualquer coisa após esse valor e adiciona reticências ("..."). Se o campo `body` for truncado, o processador relata a resposta inteira em um novo campo `body_full` no Payload. O comprimento de truncação padrão pode ser substituído por um valor de tag específico do SearchProvider (por exemplo, `max_length:256`). | Recomendado para fontes que consistentemente retornam campos de título ou corpo longos; deve seguir o `MappingResultProcessor`. |
| CleanTextResultProcessor | Remove caracteres não alfanuméricos da resposta da fonte. Deve ser considerado para respostas longas onde URLs ou outras sintaxes HTML ou Markdown aparecem nos resultados. | Deve ser instalado antes do `LenLimitingResultProcessor` quando ambos são usados. |
| DateFinderResultProcessor | Procura por uma data em qualquer formato no campo de corpo de cada item de resultado. Se encontrar uma data e o `date_published` para esse item for 'desconhecido', ele substitui o `date_published` pela data extraída do corpo e registra isso nas `result.messages`. | Este processador pode detectar os seguintes formatos de data:<br/> `06/01/23`<br/>`06/01/2023`<br/>`06-01-23`<br/>`06-01-2023`<br/>`jun 1, 2023`<br/>`june 1, 2023` |

## Processadores Pós-Resultado

Os `Processadores Pós-Resultado` operam apenas em dados de resultado que foram processados e salvos no banco de dados do Swirl por cada conector. Eles operam em objetos de resultado.

### `CosineRelevancyPostResultProcessor`

O Swirl inclui um modelo de relevância de vetor de cosseno baseado em [spaCy](https://spacy.io/). O código-fonte está em: [swirl/processors/relevancy.py](https://github.com/swirlai/swirl-search/blob/main/swirl/processors/relevancy.py)

O modelo de relevância é o seguinte:

- Correspondências em caules de palavras de [nltk](https://www.nltk.org/howto/stem.html)
- Pontua os campos configurados em `SWIRL_RELEVANCY_CONFIG` em [swirl_server/settings.py](https://github.com/swirlai/swirl-search/blob/main/swirl_server/settings.py)
- Agrega a semelhança de:

    - a consulta inteira e o campo, com a pontuação sendo a mais alta em qualquer sentença única (se houver)
    
    - a consulta inteira e uma janela de texto ao redor da correspondência do campo

    - as combinações de 1 e 2 palavras na consulta (se forem longas o suficiente) e uma janela de texto ao redor da correspondência do campo

- Pondera esses campos conforme definido em `SWIRL_RELEVANCY_CONFIG`, uma estrutura de dicionário em [swirl_server/settings.py](https://github.com/swirlai/swirl-search/blob/main/swirl_server/settings.py)

- Pondera ainda mais as correspondências de texto da janela com o comprimento da correspondência

- Dá um pequeno impulso com base na classificação original do SearchProvider, igual a $1/(1+\sqrt{SearchProvider.rank})$

- Normaliza o comprimento do resultado em relação ao comprimento mediano de todos os resultados no conjunto - isso é refletido na `result_length_adjust` na estrutura `explain`.

- Normaliza a consulta executada por este SearchProvider em relação a todas as outras consultas no conjunto - isso é refletido na `query_length_adjust` na estrutura `explain`.

A pontuação do Swirl é apenas isso: uma pontuação. Quanto maior for a pontuação, mais relevante o resultado é contextualmente. As pontuações não são comparáveis entre consultas ou resultados.

*Dica: para traduzir uma pontuação de resultado em uma pontuação de confiança, considere o resultado #1 como 1,0 e divida os resultados subsequentes pela pontuação desse resultado para calcular a confiança.*

O Swirl relata o `swirl_rank`, de 1 a N, onde N é o número total de resultados. O Swirl também inclui o `searchprovider_rank`, que é a classificação de resultado atribuída pela fonte. Isso facilita a comparação do que o Swirl considerou relevante em comparação com o que cada SearchProvider fez.

No caso de um empate de relevância, o `date_published` e a classificação do `search_provider` são usados

 como classificações adicionais, para resolvê-lo.

:key: No Swirl 2.5, o processamento de resultado foi dividido em duas etapas. O `SearchProvider.result_processors` é executado primeiro, seguido pelo `Search.post_result_processors`, que ajusta o comprimento e finaliza. Como resultado dessa alteração, o `CosineRelevancyPostResultProcessor` revisado deve ser adicionado por último na lista `Search.post_result_processors`. Por exemplo:

``` shell
    "result_processors": [
        "MappingResultProcessor",
        "DateFinderResultProcessor",
        "CosineRelevancyResultProcessor"
    ],
```

<br/>

# Misturadores

A tabela a seguir detalha os Misturadores de Resultado incluídos no Swirl:

| Misturador | Descrição | Notas |
| ---------- | ---------- | ---------- | 
| RelevancyMixer | Organiza os resultados por pontuação de [relevância](2.-User-Guide.md#relevancy-ranking) (decrescente), depois pela classificação da fonte (crescente) | O padrão; depende do `relevancy_processor` ser instalado como `search.post_result_processors` (também o padrão) |
| RelevancyNewItemsMixer | Organiza os resultados como acima, mas oculta resultados que não têm o campo `new` como [criado durante atualizações de pesquisa](5.-Developer-Guide.md#update-a-search) | Este é o padrão para `search.new_result_url`|
| DateMixer | Organiza os resultados por `date_published`. Resultados com "desconhecido" para `date_published` são omitidos | Use quando desejar resultados classificados por data | 
| DateNewItemsMixer | Organiza os resultados como acima, mas oculta resultados que não têm o campo `new` como [criado durante atualizações de pesquisa](5.-Developer-Guide.md#update-a-search) | Este é o padrão para `search.new_result_url` quando `search.date` está definido como `sort` |     
| RoundRobinMixer | Organiza os resultados pegando 1 resultado de cada SearchProvider que responde, alternando; na verdade, chama `Stack1Mixer` (veja abaixo) | Bom para pesquisas com `search.sort` definido como "date" ou sempre que desejar uma seção transversal de resultados em vez de apenas os que têm mais evidências | 
| Stack1Mixer | Organiza os resultados pegando 1 resultado de cada SearchProvider que responde, alternando | Bom para seções transversais de dados |
| Stack2Mixer | Organiza os resultados pegando 2 de cada SearchProvider que responde, alternando | Bom para seções transversais de dados com 4-6 fontes |
| Stack3Mixer | Organiza os resultados pegando 3 de cada SearchProvider que responde, alternando | Bom para seções transversais de dados com poucas fontes | 
| StackNMixer | Organiza os resultados pegando `N` de cada fonte que responde, onde `N`, se não for especificado, é o número de resultados solicitados dividido pelo número de SearchProviders que relatam pelo menos 1 resultado | Bom para seções transversais de dados com poucas fontes | 



## Mixer de Data

Se você deseja resultados classificados por `date_published`, de forma decrescente, use o Date Mixer.

![Swirl Results, Date Mixer](../images/swirl_results_mixed_2_date_sort.png)

:star: Por exemplo: [http://localhost:8000/swirl/results?search_id=1&result_mixer=DateMixer](http://localhost:8000/swirl/results?search_id=1&result_mixer=DateMixer)

## Misturadores de Novos Itens

Os dois misturadores de Novos Itens filtram automaticamente os resultados para itens com o campo `new` presente. Ambos irão relatar o número de resultados ocultos porque não têm esse campo.

Para remover o campo `new` de todos os resultados em uma pesquisa, adicione `&mark_all_as_read=1` à propriedade de URL `result_mixer`. Por exemplo:

```
http://localhost:8000/swirl/results/?search_id=1&result_mixer=DateNewItemsMixer&mark_all_as_read=1
```

O Mixer então retornará 0 resultados. Mas ele retornará resultados se a pesquisa for atualizada.

Objetos Mixer combinam objetos `Result` separados para uma determinada `Search`, envolvem-nos em metadados e os ordenam. Por exemplo, um Mixer pode alternar de cada fonte (`Stack1Mixer`) ou classificar resultados por `date_published` (`DateMixer`).

Para invocar o mixer especificado usando a propriedade `result_mixer` do objeto `Search`, especifique o `search_id` como mostrado nas APIs acima:

```
http://localhost:8000/swirl/results/?search_id=1
```

Se você usar as configurações padrão do Swirl, uma pesquisa produzirá um resultado JSON classificado por relevância.

Para especificar um Mixer diferente, adicione `&result_mixer=nome-do-mixer` à URL.

```
http://localhost:8000/swirl/results/?search_id=1&result_mixer=Stack1Mixer
```

A tabela a seguir descreve o invólucro do Mixer com mais detalhes:

| Campo | Descrição |
| ---------- | ---------- |
| messages | Todas as mensagens da Pesquisa e de todos os SearchProviders |
| info | Um dicionário de contagens de Encontrados e Recuperados de cada SearchProvider | 
| info - search | Informações sobre a Pesquisa, incluindo a consulta processada e links para reexecutar e reclassificar Pesquisas |
| info - results | Informações sobre os Resultados, incluindo o número recuperado e a URL das próximas (e anteriores) páginas de resultados |
| results | Resultados mistos da Pesquisa especificada |

<br/>

# Conjuntos de Dados de Amostra

## Conjunto de Dados de Financiamento

O conjunto de dados de financiamento da TechCrunch Continental USA foi retirado de [Insurity SpatialKey](https://support.spatialkey.com/spatialkey-sample-csv-data/). Ele está incluído no Swirl em [Data/funding_db.csv](https://github.com/swirlai/swirl-search/blob/main/Data/funding_db.csv) 
Este arquivo foi processado com [scripts/fix_csv.py](https://github.com/swirlai/swirl-search/blob/main/scripts/fix_csv.py) antes de ser carregado no SQLite3. 

### Carregando no SQLite3 

1. Ative o [sqlite_web](3.-Admin-Guide.md#sqlite-web)
Em seguida, a partir do diretório swirl-home:
``` shell
sqlite_web db.sqlite3
```

2. Uma janela do navegador deve abrir automaticamente; caso contrário, vá para [http://localhost:8080/](http://localhost:8080/)
3. Digite "funding" na caixa de texto na parte superior direita da tela e pressione o botão `Create`
![Sqlite loading funding dataset](../images/sqlite_import_funding_1.png)

4. Clique em `Choose File` e selecione [Data/funding_db.csv](https://github.com/swirlai/swirl-search/blob/main/Data/funding_db.csv)

5. Deixe "Yes" na caixa abaixo.

6. Clique em `Import`.

![Sqlite loading funding dataset](../images/sqlite_import_funding_2.png)

7. Carregue o SearchProvider [Funding DB SQLite3](https://github.com/swirlai/swirl-search/blob/main/SearchProviders/funding_db_sqlite3.json) como [descrito na seção Guia do Usuário, SearchProvider](2.-User-Guide.md#using-searchproviders).

### Carregando no PostgreSQL

* Crie uma tabela seguindo a estrutura do CSV usando SQL ou algo como o [Postico](https://eggerapps.at/postico/).


``` shell
-- DDL gerado pelo Postico 1.5.21
-- Definição da Tabela ----------------------------------------

CRIAR TABELA funding (
    id inteiro GERADO SEMPRE COMO IDENTITY PRIMARY KEY,
    permalink texto,
    empresa texto,
    numemps texto PADRÃO '0'::numeric,
    categoria texto,
    cidade texto,
    estado texto,
    datafinanciada data,
    quantiaarrecadada numeric PADRÃO '0'::numeric,
    moedaarrecadada texto,
    rodada texto
);

-- Índices -----------------------------------------------------

CRIAR ÍNDICE ÚNICO funding_pkey ON funding(id int4_ops);
```

* Execute este SQL para importar o CSV:

```
COPY funding(permalink,empresa,numemps,categoria,cidade,estado,datafinanciada,quantiaarrecadada,moedaarrecadada,rodada) FROM '/caminho/para/Data/funding_db.csv' DELIMITADOR ',' CSV CABEÇALHO;
```

* Carregue o SearchProvider [Funding DB PostgreSQL](https://github.com/swirlai/swirl-search/blob/main/SearchProviders/funding_db_postgres.json) conforme [descrito na seção User Guide, SearchProvider](2.-User-Guide.md#using-searchproviders).

### Carregando no BigQuery

* Crie uma tabela com um esquema como este:

![Esquema do BigQuery Funding DB na Console](../images/funding_bigquery_schema.png)

* Carregue o arquivo CSV nesta tabela: [Carregando dados CSV em uma tabela](https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table)

* Carregue o SearchProvider [Funding DB BigQuery](https://github.com/swirlai/swirl-search/blob/main/SearchProviders/funding_db_bigquery.json) conforme [descrito na seção User Guide, SearchProvider](2.-User-Guide.md#using-searchproviders).

## Conjunto de Dados de E-mails da Enron

Este conjunto de dados consiste em 500.000+ e-mails de 150 funcionários da antiga Enron Corporation. Está disponível no Kaggle: [https://www.kaggle.com/datasets/wcukierski/enron-email-dataset](https://www.kaggle.com/datasets/wcukierski/enron-email-dataset) entre [outros lugares](https://www.cs.cmu.edu/~./enron/).

### Carregando no Elastic ou OpenSearch

* Baixe o conjunto de dados de e-mails da Enron: https://www.cs.cmu.edu/~enron/

* Descomprima e descompacte o download e coloque o arquivo `email.csv` em seu diretório swirl-home.

* Crie um novo índice Elastic/OpenSearch chamado 'email' usando o [console de desenvolvimento](http://localhost:5601/app/dev_tools#/console):

``` shell
PUT /email
```

* Indexe os `emails.csv` do diretório Swirl:

Para o Elastic:
```
python scripts/index_email_elastic.py emails.csv -p senha-do-elastic
```

Para o OpenSearch:
```
python scripts/index_email_opensearch.py emails.csv -p senha-do-admin
```

O script reportará o progresso a cada 100 linhas. Pressione `Ctrl-C` para interrompê-lo, se desejar.

* Verifique se as mensagens foram indexadas no Elastic/OpenSearch consultando no [console de desenvolvimento](http://localhost:5601/app/dev_tools#/console):

``` shell
GET _search
{
  "query": {
    "match_all": {}
  }
}
```

Os resultados devem aparecer no painel à direita:

``` shell
{
  "took" : 38,
  "timed_out" : false,
  "_shards" : {
    "total" : 6,
    "successful" : 6,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 6799,
      "relation" : "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : ".kibana_92668751_admin_1",
        "_id" : "config:2.4.1",
        "_score" : 1.0,
        "_source" : {
          "config" : {
            "buildNum" : 4665
          },
          "type" : "config",
          "references" : [ ],
          "migrationVersion" : {
            "config" : "7.9.0"
          },
          "updated_at" : "2023-01-18T02:36:57.349Z"
        }
      },
      {
        "_index" : "email",
        "_id" : "c13MwoUBmlIzd81ioZ7H",
        "_score" : 1.0,
        "_source" : {
          "url" : "allen-p/_sent_mail/118.",
          "date_published" : "2000-09-26 09:26:00.000000",
          "author" : "Phillip K Allen",
          "to" : "pallen70@hotmail.com",
          "subject" : "Investment Structure",
          "content" : """---------------------- Encaminhado por 

    ...etc...
```

# Documentação

| [Página Inicial](index.md) | [Início Rápido](1.-Quick-Start.md) | [Guia do Usuário](2.-User-Guide.md) | [Guia do Administrador](3.-Admin-Guide.md) | [Guia do M365](4.-M365-Guide.md) | [Guia do Desenvolvedor](5.-Developer-Guide.md) | [Referência do Desenvolvedor](6.-Developer-Reference.md) |

# Suporte

* [Junte-se ao canal de suporte Swirl SEARCH no Slack!](https://join.slack.com/t/swirlmetasearch/shared_invite/zt-1qk7q02eo-kpqFAbiZJGOdqgYVvR1sfw)

* Email: [support@swirl.today](mailto:support@swirl.today) com problemas, solicitações, dúvidas, etc. - adoraríamos ouvir você!